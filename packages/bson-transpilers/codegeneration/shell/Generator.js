/*
 * This Visitor walks the AST generated by the transformers and produces code.
 * For every input language, can "inherit" the generated visitNode methods.
 */
const { removeQuotes } = require('../../helper/format');
module.exports = (superClass) => class ExtendedVisitor extends superClass {
  constructor() {
    super();
    this.regexFlags = {
      i: 'i', m: 'm', u: 'u', y: 'y', g: 'g'
    };
    this.bsonRegexFlags = {
      i: 'i', m: 'm', x: 'x', s: 's', l: 'l', u: 'u'
    };
  }

  emitNew(ctx) {
    const expr = this.getExpression(ctx);
    const str = this.visit(expr);
    ctx.type = expr.type;
    if (ctx.type.id === 'Double' || ctx.type.id === 'Symbol') {
      return str;
    }
    return this.visitChildren(ctx, {separator: ' '});
  }

  /**
   * Special case because Doubles are just number literals.
   * @param {FuncCallExpressionContext} ctx
   * @return {String}
   */
  emitDouble(ctx) {
    ctx.type = this.Types.Double;
    const argList = this.getArguments(ctx);
    const arg = this.checkArguments(this.Symbols.Double.args, argList, 'Double');
    return removeQuotes(arg[0]);
  }

  emitDate(ctx, date) {
    if (date === undefined) {
      return 'Date()';
    }
    return `Date('${date.toUTCString()}')`;
  }

  /**
   * Accepts date or number, if date then don't convert to date.
   * @param {FuncCallExpressionContext} ctx
   * @returns {String}
   */
  emitObjectIdCreateFromTime(ctx) {
    ctx.type = 'createFromTime' in this.Symbols.ObjectId.attr ?
      this.Symbols.ObjectId.attr.createFromTime :
      this.Symbols.ObjectId.attr.fromDate;
    const argList = this.getArguments(ctx);
    const args = this.checkArguments(
      ctx.type.args, argList, 'ObjectId.createFromTime'
    );
    if (this.getArgumentAt(ctx, 0).type.id === 'Date') {
      return `ObjectId.fromDate(${args[0]})`;
    }
    return `ObjectId.fromDate(new Date(${args[0]}))`;
  }
};
