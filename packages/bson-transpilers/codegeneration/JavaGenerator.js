const CodeGenerator = require('./CodeGenerator.js');

/**
 * This Visitor walks the tree generated by parsers and produces Java code.
 *
 * @returns {object}
 */
function Visitor() {
  CodeGenerator.call(this);
  return this;
}
Visitor.prototype = Object.create(CodeGenerator.prototype);
Visitor.prototype.constructor = Visitor;

Visitor.prototype.visitPropertyNameAndValueList = function(ctx) {
  return this.visitChildren(ctx, {step: 2});
};

Visitor.prototype.visitElementList = function(ctx) {
  const children = ctx.children.filter((child) => {
    return child.constructor.name !== 'TerminalNodeImpl';
  });
  return this.visitChildren(ctx,
    { children: children, separator: ', '}
  );
};

/* Ignore the new keyword because JS could either have it or not, but we always
   need it in Java so we'll add it when we call constructors. */
Visitor.prototype.visitNewExpression = function(ctx) {
  const child = this.visitChildren(ctx, { start: 1 });
  ctx.type = ctx.singleExpression().type;
  return child;
};

/* ************** Literals **************** */
Visitor.prototype.visitStringLiteral = function(ctx) {
  ctx.type = this.types.STRING;
  return this.doubleQuoteStringify(this.visitChildren(ctx));
};

Visitor.prototype.visitObjectLiteral = function(ctx) {
  let doc = 'new Document()';

  for (let i = 1; i < ctx.getChildCount() - 1; i++) {
    doc += this.visit(ctx.getChild(i));
  }
  ctx.type = this.types.OBJECT;
  return doc;
};

/* Convert each element in an object definition */
Visitor.prototype.visitPropertyExpressionAssignment = function(ctx) {
  const key = this.doubleQuoteStringify(this.visit(ctx.propertyName()));
  const value = this.visit(ctx.singleExpression());
  return `.append(${key}, ${value})`;
};

Visitor.prototype.visitArrayLiteral = function(ctx) {
  ctx.type = this.types.ARRAY;
  if (!ctx.elementList()) {
    return 'Arrays.asList()';
  }
  return `Arrays.asList(${this.visit(ctx.elementList())})`;
};

Visitor.prototype.visitUndefinedLiteral = function(ctx) {
  ctx.type = this.types.UNDEFINED;
  return 'null';
};

Visitor.prototype.visitElision = function(ctx) {
  ctx.type = this.types.NULL;
  return 'null';
};

Visitor.prototype.visitOctalIntegerLiteral = function(ctx) {
  ctx.type = this.types.OCTAL;
  let oct = this.visitChildren(ctx);
  if ((oct.charAt(0) === '0' && oct.charAt(1) === '0') ||
    (oct.charAt(0) === '0' && (oct.charAt(1) === 'o' || oct.charAt(1) === 'O'))) {
    oct = '0' + oct.substr(2, oct.length - 1);
  }
  return oct;
};

/*  ************** Built-in JS Identifiers **************** */
Visitor.prototype.visitObjectCreateConstructorExpression = function(ctx) {
  const args = ctx.getChild(1);

  if (args.getChildCount() === 2 || args.getChild(1).getChildCount() !== 1) {
    return 'Error: Object.create() requires one argument';
  }

  const arg = args.getChild(1).getChild(0);
  const obj = this.visit(arg);

  if (arg.type !== this.types.OBJECT) {
    return 'Error: Object.create() requires an object argument';
  }

  return obj;
};

Visitor.prototype.visitNumberConstructorExpression = function(ctx) {
  const args = ctx.getChild(1);

  if (args.getChildCount() !== 3 || args.getChild(1).getChildCount() !== 1) {
    return 'Error: Number requires one argument';
  }

  const number = this.visit(args.getChild(1));

  if (
    (
      args.getChild(1).type !== this.types.STRING &&
      args.getChild(1).type !== this.types.DECIMAL &&
      args.getChild(1).type !== this.types.INTEGER
    ) ||
    isNaN(parseInt(this.removeQuotes(number), 10))
  ) {
    return 'Error: Number requires a number or a string argument';
  }

  return `new java.lang.Integer(${number})`;
};

Visitor.prototype.visitDateConstructorExpression = function(ctx) {
  const args = ctx.getChild(1);
  if (args.getChildCount() === 2) {
    return 'new java.util.Date()';
  }
  let epoch;
  try {
    epoch = this.executeJavascript(ctx.getText()).getTime();
  } catch (error) {
    return error.message;
  }
  return `new java.util.Date(${epoch})`;
};

Visitor.prototype.visitDateNowConstructorExpression = function() {
  return 'new java.util.Date()';
};

// TODO: RegExps are unfinished
Visitor.prototype.visitRegExpConstructorExpression =
Visitor.prototype.visitRegularExpressionLiteral = function(ctx) {
  let pattern;
  let flags;
  try {
    const regexobj = this.executeJavascript(ctx.getText());
    pattern = regexobj.source;
    flags = regexobj.flags;
  } catch (error) {
    return error.message;
  }
  return `Pattern.compile(${this.doubleQuoteStringify(pattern)}, ${flags})`;
};

/*  ************** BSON Constructors **************** */

/* The arguments to Code can be either a string or actual javascript code. */
Visitor.prototype.visitBSONCodeConstructor = function(ctx) {
  const args = ctx.getChild(1);
  if (args.getChildCount() === 2 ||
     !(args.getChild(1).getChildCount() === 3 ||
       args.getChild(1).getChildCount() === 1)) {
    return 'Error: Code requires one or two arguments';
  }
  const argList = args.getChild(1);
  const code = this.doubleQuoteStringify(argList.getChild(0).getText());

  if (argList.getChildCount() === 3) {
    /* NOTE: we have to visit the subtree first before type checking or type may
       not be set. We might have to just suck it up and do two passes, but maybe
       we can avoid it for now. */
    const scope = this.visit(argList.getChild(2));
    if (argList.getChild(2).type !== this.types.OBJECT) {
      return 'Error: Code requires scope to be an object';
    }
    return `new CodeWithScope(${code}, ${scope})`;
  }
  return `new Code(${code})`;
};

/* This evaluates the code in a sandbox and gets the hex string out of the
   ObjectId. */
Visitor.prototype.visitBSONObjectIdConstructor = function(ctx) {
  const args = ctx.getChild(1);
  if (args.getChildCount() === 2) {
    return 'new ObjectId()';
  }
  let hexstr;
  try {
    hexstr = this.executeJavascript(ctx.getText()).toHexString();
  } catch (error) {
    return error.message;
  }
  return `new ObjectId(${this.doubleQuoteStringify(hexstr)})`;
};

Visitor.prototype.visitBSONBinaryConstructor = function(ctx) {
  let type;
  let binobj;
  try {
    binobj = this.executeJavascript(ctx.getText());
    type = binobj.sub_type;
  } catch (error) {
    return error.message;
  }
  const subtypes = {
    0: 'org.bson.BsonBinarySubType.BINARY',
    1: 'org.bson.BsonBinarySubType.FUNCTION',
    2: 'org.bson.BsonBinarySubType.BINARY',
    3: 'org.bson.BsonBinarySubType.UUID_LEGACY',
    4: 'org.bson.BsonBinarySubType.UUID',
    5: 'org.bson.BsonBinarySubType.MD5',
    128: 'org.bson.BsonBinarySubType.USER_DEFINED'
  };

  const bytes = this.doubleQuoteStringify(binobj.toString());
  return `new Binary(${subtypes[type]}, ${bytes}.getBytes("UTF-8"))`;
};

Visitor.prototype.visitBSONDBRefConstructor = function(ctx) {
  const args = ctx.getChild(1);
  if (args.getChildCount() === 2 ||
    !(args.getChild(1).getChildCount() === 5 ||
      args.getChild(1).getChildCount() === 3)) {
    return 'Error: DBRef requires two or three arguments';
  }
  const argList = args.getChild(1);
  const ns = this.visit(argList.getChild(0));
  if (argList.getChild(0).type !== this.types.STRING) {
    return 'Error: DBRef requires string namespace';
  }
  const oid = this.visit(argList.getChild(2));
  if (argList.getChild(2).type !== this.types.OBJECT) {
    return 'Error: DBRef requires object OID';
  }

  if (argList.getChildCount() === 5) {
    const db = this.visit(argList.getChild(4));
    if (argList.getChild(4).type !== this.types.STRING) {
      return 'Error: DbRef requires string collection';
    }
    return `new DBRef(${ns}, ${oid}, ${db})`;
  }
  return `new DBRef(${ns}, ${oid})`;
};

Visitor.prototype.visitBSONDoubleConstructor = function(ctx) {
  const args = ctx.getChild(1);
  if (args.getChildCount() === 2 || args.getChild(1).getChildCount() !== 1) {
    return 'Error: Double requires one argument';
  }
  const arg = args.getChild(1).getChild(0);
  const value = this.visit(arg);
  if (arg.type !== this.types.STRING && !this.isNumericType(arg)) {
    // This is actually what java accepts
    return 'Error: Double requires either string or number';
  }
  return `new java.lang.Double(${value})`;
};

Visitor.prototype.visitBSONLongConstructor = function(ctx) {
  let longstr;
  try {
    longstr = this.executeJavascript(ctx.getText()).toString();
  } catch (error) {
    return error.message;
  }
  return `new java.lang.Long(${this.doubleQuoteStringify(longstr)})`;
};

Visitor.prototype.visitBSONMaxKeyConstructor = function() {
  return 'new MaxKey()';
};

Visitor.prototype.visitBSONMinKeyConstructor = function() {
  return 'new MinKey()';
};

Visitor.prototype.visitBSONRegExpConstructor = function(ctx) {
  let pattern;
  let flags;
  try {
    const regexobj = this.executeJavascript(ctx.getText());
    pattern = regexobj.pattern;
    flags = regexobj.flags;
  } catch (error) {
    return error.message;
  }
  return `Pattern.compile(${this.doubleQuoteStringify(pattern)}, ${flags})`;
};

Visitor.prototype.visitBSONSymbolConstructor = function(ctx) {
  const args = ctx.getChild(1);
  if (args.getChildCount() === 2 || args.getChild(1).getChildCount() !== 1) {
    return 'Error: Symbol requires one argument';
  }
  const arg = args.getChild(1).getChild(0);
  const symbol = this.visit(arg);
  if (arg.type !== this.types.STRING) {
    return 'Error: Symbol requires a string argument';
  }
  return `new Symbol(${symbol})`;
};

Visitor.prototype.visitBSONTimestampConstructor = function(ctx) {
  const args = ctx.getChild(1);
  if (args.getChildCount() === 2 ||
      !(args.getChild(1).getChildCount() === 3)) {
    return 'Error: Timestamp requires two arguments';
  }
  const argList = args.getChild(1);
  const low = this.visit(argList.getChild(0));
  if (argList.getChild(0).type !== this.types.INTEGER) {
    return 'Error: Timestamp requires integer arguments';
  }
  const high = this.visit(argList.getChild(2));
  if (argList.getChild(2).type !== this.types.INTEGER) {
    return 'Error: Timestamp requires integer arguments';
  }
  return `new BSONTimestamp(${low}, ${high})`;
};

// TODO
// Visitor.prototype.visitBSONDecimal128Constructor = function(ctx) {
// };

module.exports = Visitor;
