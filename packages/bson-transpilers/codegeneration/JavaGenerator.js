/* eslint complexity: 0 */
const CodeGenerator = require('./CodeGenerator.js');
const {
  Types,
  JSClasses,
  BsonClasses,
  BsonSymbols,
  JSSymbols,
  Symbols
} = require('./SymbolTable');

const JAVA_REGEX_FLAGS = {
  i: 'i', m: 'm', u: 'u', y: '', g: ''
};

const JAVA_BINARY_SUBTYPES = {
  0: 'org.bson.BsonBinarySubType.BINARY',
  1: 'org.bson.BsonBinarySubType.FUNCTION',
  2: 'org.bson.BsonBinarySubType.BINARY',
  3: 'org.bson.BsonBinarySubType.UUID_LEGACY',
  4: 'org.bson.BsonBinarySubType.UUID',
  5: 'org.bson.BsonBinarySubType.MD5',
  128: 'org.bson.BsonBinarySubType.USER_DEFINED'
};


/**
 * This Visitor walks the tree generated by parsers and produces Java code.
 *
 * @returns {object}
 */
function Visitor() {
  CodeGenerator.call(this);
  return this;
}
Visitor.prototype = Object.create(CodeGenerator.prototype);
Visitor.prototype.constructor = Visitor;

/**
 * Child nodes: propertyAssignment+
 *
 * @param {PropertyNameAndValueListContext} ctx
 * @return {String}
 */
Visitor.prototype.visitPropertyNameAndValueList = function(ctx) {
  return this.visitChildren(ctx, {children: ctx.propertyAssignment()});
};

/**
 * Child nodes: (elision* singleExpression*)+
 * @param {ElementListContext} ctx
 * @return {String}
 */
Visitor.prototype.visitElementList = function(ctx) {
  const children = ctx.children.filter((child) => {
    return child.constructor.name !== 'TerminalNodeImpl';
  });
  return this.visitChildren(ctx,
    { children: children, separator: ', '}
  );
};

/**
 * Ignore the new keyword because JS could either have it or not, but we always
 * need it in Java so we'll add it when we call constructors.
 * TODO: do we ever need the second arguments expr?
 *
 * Child nodes: singleExpression arguments?
 *
 * @param {NewExpressionContext} ctx
 * @return {String}
 */
Visitor.prototype.visitNewExpression = function(ctx) {
  const expr = this.visit(ctx.singleExpression());
  ctx.type = ctx.singleExpression().type;
  return expr;
};

Visitor.prototype.visitFuncCallExpression = function(ctx) {
  this.visit(ctx.singleExpression());
  const lhsType = ctx.singleExpression().type;

  // Special case types
  if (`emit${lhsType.id}` in this) {
    return this[`emit${lhsType.id}`](ctx);
  }

  // This is where, if the target language func id is different from the input language, it can be switched out.
  return this.emitType(lhsType.id, ctx);
};

Visitor.prototype.visitBSONIdentifierExpression = function(ctx) {
  const name = this.visitChildren(ctx);
  ctx.type = BsonSymbols[name];
  return name;
};

Visitor.prototype.visitJSIdentifierExpression = function(ctx) {
  const name = this.visitChildren(ctx);
  ctx.type = JSSymbols[name];
  return name;
};

Visitor.prototype.visitIdentifierExpression = function(ctx) {
  const name = this.visitChildren(ctx);
  ctx.type = Symbols[name];
  return name;
};

Visitor.prototype.visitMemberDotExpression = function(ctx) {
  const lhs = this.visit(ctx.singleExpression());
  const lhsType = ctx.singleExpression().type;

  const rhs = this.visit(ctx.identifierName());

  if (!(rhs in lhsType.attr)) {
    throw `Error: ${rhs} not an attribute of ${lhsType.id}`;
  }
  ctx.type = lhsType.attr[rhs];
  return `${lhs}.${rhs}`;
};

/* ************** Literals **************** */

/**
 * Child nodes: DoubleStringCharacter* | SingleStringCharacter*
 * @param {StringLiteralContext} ctx
 * @return {String}
 */
Visitor.prototype.visitStringLiteral = function(ctx) {
  ctx.type = Types._string;
  return this.doubleQuoteStringify(this.visitChildren(ctx));
};

/**
 * Child nodes: propertyNameAndValueList?
 * @param {ObjectLiteralContext} ctx
 * @return {String}
 */
Visitor.prototype.visitObjectLiteral = function(ctx) {
  ctx.type = Types._object;
  let chain = '';
  if (ctx.propertyNameAndValueList()) {
    chain = this.visit(ctx.propertyNameAndValueList());
  }
  return `new Document()${chain}`;
};

/**
 * Child nodes: propertyName singleExpression
 * @param {PropertyAssignmentExpressionContext} ctx
 * @return {String}
 */
Visitor.prototype.visitPropertyAssignmentExpression = function(ctx) {
  const key = this.doubleQuoteStringify(this.visit(ctx.propertyName()));
  const value = this.visit(ctx.singleExpression());
  return `.append(${key}, ${value})`;
};

/**
 * Child nodes: elementList*
 * @param {ArrayLiteralContext} ctx
 * @return {String}
 */
Visitor.prototype.visitArrayLiteral = function(ctx) {
  ctx.type = Types._array;
  if (!ctx.elementList()) {
    return 'Arrays.asList()';
  }
  return `Arrays.asList(${this.visit(ctx.elementList())})`;
};

/**
 * One terminal child.
 * @param {UndefinedLiteralContext} ctx
 * @return {String}
 */
Visitor.prototype.visitUndefinedLiteral = function(ctx) {
  ctx.type = Types._undefined;
  return 'null';
};

/**
 * One terminal child.
 * @param {ElisionContext} ctx
 * @return {String}
 */
Visitor.prototype.visitElision = function(ctx) {
  ctx.type = Types._null;
  return 'null';
};

/**
 * One terminal child.
 * @param {OctalIntegerLiteralContext} ctx
 * @return {String}
 */
Visitor.prototype.visitOctalIntegerLiteral = function(ctx) {
  ctx.type = Types._octal;
  let oct = this.visitChildren(ctx);
  if ((oct.charAt(0) === '0' && oct.charAt(1) === '0') ||
    (oct.charAt(0) === '0' && (oct.charAt(1) === 'o' || oct.charAt(1) === 'O'))) {
    oct = '0' + oct.substr(2, oct.length - 1);
  }
  return oct;
};

/*  ************** Built-in JS Identifiers **************** */

/**
 * child nodes: arguments
 * grandchild nodes: argumentList?
 * great-grandchild nodes: singleExpression+
 * @param {ObjectCreateConstructorExpressionContext} ctx
 * @return {String}
 */
Visitor.prototype.visitObjectCreateConstructorExpression = function(ctx) {
  ctx.type = Types._object;
  const argList = ctx.arguments().argumentList();

  if (!argList || argList.singleExpression().length !== 1) {
    return 'Error: Object.create() requires one argument';
  }

  const arg = argList.singleExpression()[0];
  const obj = this.visit(arg);

  if (arg.type !== Types._object) {
    return 'Error: Object.create() requires an object argument';
  }

  return obj;
};

/**
 * child nodes: arguments
 * grandchild nodes: argumentList?
 * great-grandchild nodes: singleExpression+
 * @param {ObjectCreateConstructorExpressionContext} ctx
 * @return {String}
 */
Visitor.prototype.visitNumberConstructorExpression = function(ctx) {
  ctx.type = JSClasses.Number;
  const argList = ctx.arguments().argumentList();

  if (!argList || argList.singleExpression().length !== 1) {
    return 'Error: Number requires one argument';
  }

  const arg = argList.singleExpression()[0];
  const number = this.visit(arg);

  if (
    (
      arg.type !== Types._string &&
      arg.type !== Types._decimal &&
      arg.type !== Types._integer
    ) ||
    isNaN(parseInt(this.removeQuotes(number), 10))
  ) {
    return 'Error: Number requires a number or a string argument';
  }

  return `new java.lang.Integer(${number})`;
};

/**
 * child nodes: arguments
 * grandchild nodes: argumentList?
 * great-grandchild nodes: singleExpression+
 * @param {DateConstructorExpressionContext} ctx
 * @return {String}
 */
Visitor.prototype.visitDateConstructorExpression = function(ctx) {
  ctx.type = JSClasses.Date;
  const args = ctx.arguments();
  if (!args.argumentList()) {
    return 'new java.util.Date()';
  }
  let epoch;
  try {
    epoch = this.executeJavascript(ctx.getText()).getTime();
  } catch (error) {
    return error.message;
  }
  return `new java.util.Date(${epoch})`;
};

// Visitor.prototype.visitDateNowConstructorExpression = function() {
//   return 'new java.util.Date()';
// };

/**
 * child nodes: arguments
 * grandchild nodes: argumentList?
 * great-grandchild nodes: singleExpression+
 * @param {RegExpConstructorExpressionContext} ctx
 * @return {String}
 */
Visitor.prototype.visitRegExpConstructorExpression =
Visitor.prototype.visitRegularExpressionLiteral = function(ctx) {
  ctx.type = JSClasses.Regex;
  let pattern;
  let flags;
  try {
    const regexobj = this.executeJavascript(ctx.getText());
    pattern = regexobj.source;
    flags = regexobj.flags;
  } catch (error) {
    return error.message;
  }

  let javaflags = flags.replace(/[imuyg]/g, m => JAVA_REGEX_FLAGS[m]);
  javaflags = javaflags === '' ? '' : `(?${javaflags})`;

  // Double escape characters except for slashes
  const escaped = pattern.replace(/\\(?!\/)/, '\\\\');

  return `Pattern.compile(${this.doubleQuoteStringify(escaped + javaflags)})`;
};

/*  ************** BSON Constructors **************** */

/**
 * The arguments to Code can be either a string or actual javascript code.
 *
 * child nodes: arguments
 * grandchild nodes: argumentList?
 * great-grandchild nodes: singleExpression+
 * @param {FuncCallExpressionContext} ctx
 * @return {String}
 */
Visitor.prototype.emitCode = function(ctx) {
  ctx.type = BsonClasses.Code;
  const argList = ctx.arguments().argumentList();
  if (!argList ||
     !(argList.singleExpression().length === 1 ||
       argList.singleExpression().length === 2)) {
    return 'Error: Code requires one or two arguments';
  }
  const args = argList.singleExpression();
  const code = this.doubleQuoteStringify(args[0].getText());

  if (args.length === 2) {
    /* NOTE: we have to visit the subtree first before type checking or type may
       not be set. We might have to just suck it up and do two passes, but maybe
       we can avoid it for now. */
    const scope = this.visit(args[1]);
    if (args[1].type !== Types._object) {
      return 'Error: Code requires scope to be an object';
    }
    return `new CodeWithScope(${code}, ${scope})`;
  }

  return `new Code(${code})`;
};

/**
 * child nodes: arguments
 * grandchild nodes: argumentList?
 * great-grandchild nodes: singleExpression+
 * @param {FuncCallExpressionContext} ctx
 * @return {String}
 */
Visitor.prototype.emitObjectId = function(ctx) {
  ctx.type = BsonClasses.ObjectId;
  const argList = ctx.arguments().argumentList();
  if (!argList) {
    return 'new ObjectId()';
  }
  let hexstr;
  try {
    hexstr = this.executeJavascript(ctx.getText()).toHexString();
  } catch (error) {
    return error.message;
  }
  return `new ObjectId(${this.doubleQuoteStringify(hexstr)})`;
};

/**
 * child nodes: arguments
 * grandchild nodes: argumentList?
 * great-grandchild nodes: singleExpression+
 * @param {FuncCallExpressionContext} ctx
 * @return {String}
 */
Visitor.prototype.emitBinary = function(ctx) {
  ctx.type = BsonClasses.Binary;
  let type;
  let binobj;
  try {
    binobj = this.executeJavascript(ctx.getText());
    type = binobj.sub_type;
  } catch (error) {
    return error.message;
  }
  const bytes = this.doubleQuoteStringify(binobj.toString());
  return `new Binary(${JAVA_BINARY_SUBTYPES[type]}, ${bytes}.getBytes("UTF-8"))`;
};

// /**
//  * child nodes: arguments
//  * grandchild nodes: argumentList?
//  * great-grandchild nodes: singleExpression+
//  * @param {BSONDBRefConstructorContext} ctx
//  * @return {String}
//  */
// Visitor.prototype.visitBSONDBRefConstructor = function(ctx) {
//   ctx.type = BsonClasses.DBRef;
//   const argList = ctx.arguments().argumentList();
//   if (!argList ||
//       !(argList.singleExpression().length === 2 ||
//         argList.singleExpression().length === 3)) {
//     return 'Error: DBRef requires two or three arguments';
//   }
//   const args = argList.singleExpression();
//   const ns = this.visit(args[0]);
//   if (args[0].type !== Types._string) {
//     return 'Error: DBRef requires string namespace';
//   }
//   const oid = this.visit(args[1]);
//   if (args[1].type !== Types._string) {
//     return 'Error: DBRef requires object OID';
//   }
//
//   if (args.length === 3) {
//     const db = this.visit(args[2]);
//     if (args[2].type !== Types._string) {
//       return 'Error: DbRef requires string collection';
//     }
//     return `new DBRef(${ns}, ${oid}, ${db})`;
//   }
//   return `new DBRef(${ns}, ${oid})`;
// };
//
// /**
//  * child nodes: arguments
//  * grandchild nodes: argumentList?
//  * great-grandchild nodes: singleExpression+
//  * @param {BSONDoubleConstructorContext} ctx
//  * @return {String}
//  */
// Visitor.prototype.visitBSONDoubleConstructor = function(ctx) {
//   ctx.type = BsonClasses.Double;
//   const argList = ctx.arguments().argumentList();
//   if (!argList || argList.singleExpression().length !== 1) {
//     return 'Error: Double requires one argument';
//   }
//   const arg = argList.singleExpression()[0];
//   const value = this.visit(arg);
//   if (arg.type !== Types._string && !this.isNumericType(arg)) {
//     // This is actually what java accepts
//     return 'Error: Double requires either string or number';
//   }
//   return `new java.lang.Double(${value})`;
// };

/**
 * child nodes: arguments
 * grandchild nodes: argumentList?
 * great-grandchild nodes: singleExpression+
 * @param {FuncCallExpressionContext} ctx
 * @return {String}
 */
Visitor.prototype.emitLong = function(ctx) {
  ctx.type = BsonClasses.Long;
  let longstr;
  try {
    longstr = this.executeJavascript(ctx.getText()).toString();
  } catch (error) {
    return error.message;
  }
  return `new java.lang.Long(${this.doubleQuoteStringify(longstr)})`;
};

// Visitor.prototype.visitBSONMaxKeyConstructor = function(ctx) {
//   ctx.type = BsonClasses.MaxKey;
//   return 'new MaxKey()';
// };
//
// Visitor.prototype.visitBSONMinKeyConstructor = function(ctx) {
//   ctx.type = BsonClasses.MinKey;
//   return 'new MinKey()';
// };

/**
 * Expects two strings as arguments, the second must contain any of "imxlsu"
 *
 * child nodes: arguments
 * grandchild nodes: argumentList?
 * great-grandchild nodes: singleExpression+
 * @param {FuncCallExpressionContext} ctx
 * @return {String}
 */
Visitor.prototype.emitBSONRegExp = function(ctx) {
  ctx.type = BsonClasses.RegExp;
  const argList = ctx.arguments().argumentList();
  if (!argList ||
      !(argList.singleExpression().length === 1 ||
        argList.singleExpression().length === 2)) {
    return 'Error: BSONRegExp requires one or two arguments';
  }
  const args = argList.singleExpression();
  const pattern = this.visit(args[0]);
  if (args[0].type !== Types._string) {
    return 'Error: BSONRegExp requires pattern to be a string';
  }

  if (args.length === 2) {
    const flags = this.visit(args[1]);
    if (args[1].type !== Types._string) {
      return 'Error: BSONRegExp requires flags to be a string';
    }
    for (let i = 1; i < flags.length - 1; i++) {
      if (
        !(
          flags[i] === 'i' ||
          flags[i] === 'm' ||
          flags[i] === 'x' ||
          flags[i] === 'l' ||
          flags[i] === 's' ||
          flags[i] === 'u'
        )
      ) {
        return `Error: the regular expression options [${flags[i]}] is not supported`;
      }
    }
    return `new BsonRegularExpression(${pattern}, ${flags})`;
  }
  return `new BsonRegularExpression(${pattern})`;
};

// /**
//  * child nodes: arguments
//  * grandchild nodes: argumentList?
//  * great-grandchild nodes: singleExpression+
//  * @param {BSONSymbolConstructorContext} ctx
//  * @return {String}
//  */
// Visitor.prototype.visitBSONSymbolConstructor = function(ctx) {
//   ctx.type = BsonClasses.Symbol;
//   const argList = ctx.arguments().argumentList();
//   if (!argList || argList.singleExpression().length !== 1) {
//     return 'Error: Symbol requires one argument';
//   }
//   const arg = argList.singleExpression()[0];
//   const symbol = this.visit(arg);
//   if (arg.type !== Types._string) {
//     return 'Error: Symbol requires a string argument';
//   }
//   return `new Symbol(${symbol})`;
// };
//
// /**
//  * child nodes: arguments
//  * grandchild nodes: argumentList?
//  * great-grandchild nodes: singleExpression+
//  * @param {BSONTimestampConstructorContext} ctx
//  * @return {String}
//  */
// Visitor.prototype.visitBSONTimestampConstructor = function(ctx) {
//   ctx.type = BsonClasses.Timestamp;
//   const argList = ctx.arguments().argumentList();
//   if (!argList || argList.singleExpression().length !== 2) {
//     return 'Error: Timestamp requires two arguments';
//   }
//   const args = argList.singleExpression();
//   const low = this.visit(args[0]);
//   if (args[0].type !== Types._integer) {
//     return 'Error: Timestamp requires integer arguments';
//   }
//   const high = this.visit(args[1]);
//   if (args[1].type !== Types._integer) {
//     return 'Error: Timestamp requires integer arguments';
//   }
//   return `new BSONTimestamp(${low}, ${high})`;
// };

// TODO
// Visitor.prototype.visitBSONDecimal128Constructor = function(ctx) {
// };

module.exports = Visitor;
